<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MyKo101</title>
    <link>https://michaelbarrowman.co.uk/</link>
      <atom:link href="https://michaelbarrowman.co.uk/index.xml" rel="self" type="application/rss+xml" />
    <description>MyKo101</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Michael Barrowman © 2020</copyright><lastBuildDate>Thu, 15 Oct 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://michaelbarrowman.co.uk/images/icon_hufb6089c2dae8ab059339a50c00192ccd_27937_512x512_fill_lanczos_center_2.png</url>
      <title>MyKo101</title>
      <link>https://michaelbarrowman.co.uk/</link>
    </image>
    
    <item>
      <title>mpipe</title>
      <link>https://michaelbarrowman.co.uk/package/mpipe/</link>
      <pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/package/mpipe/</guid>
      <description>&lt;p&gt;&lt;img src = &#34;featured.png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mutils</title>
      <link>https://michaelbarrowman.co.uk/package/mutils/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/package/mutils/</guid>
      <description></description>
    </item>
    
    <item>
      <title>typos</title>
      <link>https://michaelbarrowman.co.uk/package/typos/</link>
      <pubDate>Sun, 14 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/package/typos/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Convert all Character variables to Factors</title>
      <link>https://michaelbarrowman.co.uk/post/convert-all-character-variables-to-factors/</link>
      <pubDate>Thu, 15 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/post/convert-all-character-variables-to-factors/</guid>
      <description>
&lt;script src=&#34;https://michaelbarrowman.co.uk/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;First, let’s load up what we need!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(15102020)
library(tidyverse) #We&amp;#39;ll use tidyverse functions
library(magrittr) #A few extra pipes from magrittr
library(lexicon) #For a word dictionary&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When dealing wth complex datasets, it is common that a variable may be stored as a &lt;em&gt;character&lt;/em&gt; variable, when in reality what you want is a &lt;em&gt;factor&lt;/em&gt; variable. On the surface, these two constructs look very similar:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eg_df &amp;lt;- tibble(
  c_var = c(&amp;quot;Cat&amp;quot;,&amp;quot;Dog&amp;quot;,&amp;quot;Cat&amp;quot;,&amp;quot;Mouse&amp;quot;,&amp;quot;Mouse&amp;quot;),
  f_var = factor(c(&amp;quot;Cat&amp;quot;,&amp;quot;Dog&amp;quot;,&amp;quot;Cat&amp;quot;,&amp;quot;Mouse&amp;quot;,&amp;quot;Mouse&amp;quot;))
)
eg_df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 2
##   c_var f_var
##   &amp;lt;chr&amp;gt; &amp;lt;fct&amp;gt;
## 1 Cat   Cat  
## 2 Dog   Dog  
## 3 Cat   Cat  
## 4 Mouse Mouse
## 5 Mouse Mouse&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, underneath they are treated quite differently. Behind the scenes, the factors are actually stored as integers with a special lookup table called their &lt;em&gt;levels&lt;/em&gt;, which can be seen if we print the variable individually:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eg_df$f_var&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] Cat   Dog   Cat   Mouse Mouse
## Levels: Cat Dog Mouse&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also see the hidden numbers by converting this to numeric:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.numeric(eg_df$f_var)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 1 3 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first element, &lt;code&gt;Cat&lt;/code&gt; is associated with the first level, so it is stored as a &lt;code&gt;1&lt;/code&gt;, the third element is also &lt;code&gt;Cat&lt;/code&gt;, so it is also stored as a &lt;code&gt;1&lt;/code&gt;. The fourth &amp;amp; fifth are both &lt;code&gt;Mouse&lt;/code&gt; and so they’re stored as &lt;code&gt;3&lt;/code&gt;, indicating to use the third level.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;why-factors&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Why factors?&lt;/h1&gt;
&lt;p&gt;Most statistical operations within R that can act on a &lt;em&gt;character&lt;/em&gt; variable will essentially convert to a &lt;em&gt;factor&lt;/em&gt; first. So, it’s more efficient to convert characters to factors before passing them into these kinds of functions. This also gives us more control over what we’re going to get.&lt;/p&gt;
&lt;p&gt;This conversion makes many processes that work with characters a bit slow. If you’re wanting to do 20 functions on a data set and each one needs to convert your characters to factors internally before doing what it needs to, it’s clearly much faster to manually convert &lt;em&gt;once&lt;/em&gt; before using these functions.&lt;/p&gt;
&lt;p&gt;Factors also take up slightly less space in your system’s memory. In R, this is approximately half the space of a character, however the way R stores this kind of data is surprisingly efficient. It’s definitely a good habit to get into if you ever want to move onto less efficient storage methods.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;converting&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Converting&lt;/h1&gt;
&lt;p&gt;Above, I used the &lt;code&gt;factor()&lt;/code&gt; function to quickly convert a single character variable to a factor variable. But what about if you’ve got a large dataset with many, many character variables that you want to convert to factors. What’s the smoothest way to do this?&lt;/p&gt;
&lt;div id=&#34;example-random-dataset&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example random dataset&lt;/h2&gt;
&lt;p&gt;First, let’s create a large dataset, we’ll loop through a bunch of columns. We’ll use Fry’s 1000 Most Commonly Use English Words, as found in the &lt;code&gt;sw_fry_1000&lt;/code&gt; dataset from the &lt;code&gt;{lexicon}&lt;/code&gt; package to choose random words for each variable. We’ll also throw in some numeric variables to make things harder:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- tibble(id=1:1000) #declare a tibble with just an id variable
for(i in 1:10)
{
  #How many distinct words should this variable have?
  distinct_words &amp;lt;- round(rexp(1,1/20)) +1
  
  #What words can we choose from for this variable?
  these_words &amp;lt;- sample(sw_fry_1000,distinct_words)
  
  #What&amp;#39;s the name of this variable?
  this_name &amp;lt;- paste0(&amp;quot;var_&amp;quot;,ncol(df) + 1)
  
  #Generate the variable
  this_variable &amp;lt;- sample(these_words,1000,replace=T)
  
  #Store it in the tibble
  df[[this_name]] &amp;lt;- this_variable
  
  #Approximated 1/3 of the time, we&amp;#39;ll add a numeric variable
  if(rbinom(1,1,1/3) == 1){
    this_name &amp;lt;- paste0(&amp;quot;var_&amp;quot;,ncol(df)+1)
    
    df[[this_name]] &amp;lt;- rnorm(1000)
  }
  
}
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,000 x 14
##       id var_2   var_3 var_4 var_5 var_6 var_7 var_8 var_9 var_10  var_11 var_12
##    &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; 
##  1     1 prop~  1.83   row   gove~ gene~ cow   else  women length  0.249  home  
##  2     2 four  -0.225  wind~ reas~ speak cow   squa~ gold  exerc~  0.688  numer~
##  3     3 leave  0.367  gold  plant came  cow   egg   human exerc~ -0.517  tell  
##  4     4 rock   0.919  that  meat  gene~ cow   leave human skill  -0.280  fill  
##  5     5 favor -1.01   mile  nine  tree  cow   very  hand  has    -0.0302 left  
##  6     6 shop   1.14   hunt  drink speak cow   take  meat  hit     0.908  over  
##  7     7 end    0.0427 engi~ seas~ gene~ cow   art   women exerc~  0.0395 unit  
##  8     8 favor -0.647  body  drink gene~ cow   diff~ doll~ most   -0.458  people
##  9     9 earth -2.47   fight nine  tree  cow   deci~ air   king    0.0182 child 
## 10    10 end    1.35   prot~ drink speak cow   carry women grand  -0.978  conti~
## # ... with 990 more rows, and 2 more variables: var_13 &amp;lt;chr&amp;gt;, var_14 &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The generation of this data is actually rather clunky as it’s using a loop, and we’re going to avoid that. Instead, we’re going to turn all these characters into factors in a single line. Here’s the line of code which will update the dataset, followed by the explanation:&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;the-solution&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The solution&lt;/h1&gt;
&lt;p&gt;With &lt;code&gt;{tidyverse}&lt;/code&gt; processes, the key thing we’re trying to do is build a “sentence” explaining what we’re doing. Here’s our expression, followed by the English sentence equivalent&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df %&amp;lt;&amp;gt;% mutate(across(where(is.character),as_factor))
#Update the df by mutating it across variables where it is a
#   character by performing as_factor on them

df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,000 x 14
##       id var_2   var_3 var_4 var_5 var_6 var_7 var_8 var_9 var_10  var_11 var_12
##    &amp;lt;int&amp;gt; &amp;lt;fct&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;fct&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt; 
##  1     1 prop~  1.83   row   gove~ gene~ cow   else  women length  0.249  home  
##  2     2 four  -0.225  wind~ reas~ speak cow   squa~ gold  exerc~  0.688  numer~
##  3     3 leave  0.367  gold  plant came  cow   egg   human exerc~ -0.517  tell  
##  4     4 rock   0.919  that  meat  gene~ cow   leave human skill  -0.280  fill  
##  5     5 favor -1.01   mile  nine  tree  cow   very  hand  has    -0.0302 left  
##  6     6 shop   1.14   hunt  drink speak cow   take  meat  hit     0.908  over  
##  7     7 end    0.0427 engi~ seas~ gene~ cow   art   women exerc~  0.0395 unit  
##  8     8 favor -0.647  body  drink gene~ cow   diff~ doll~ most   -0.458  people
##  9     9 earth -2.47   fight nine  tree  cow   deci~ air   king    0.0182 child 
## 10    10 end    1.35   prot~ drink speak cow   carry women grand  -0.978  conti~
## # ... with 990 more rows, and 2 more variables: var_13 &amp;lt;fct&amp;gt;, var_14 &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And as if by magic, all of the characters are now factors (note the &lt;code&gt;&amp;lt;fct&amp;gt;&lt;/code&gt; under the variable names).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-explanation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The Explanation&lt;/h1&gt;
&lt;p&gt;The above code uses five functions, and an operation to perform the action. We’ll dig down into the functions and then climb back out as their results are processed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%&amp;lt;&amp;gt;%&lt;/code&gt; grabs the tibble on it’s left hand side and passes it to the function on the right. At this point, it works exactly like the regular &lt;code&gt;%&amp;gt;%&lt;/code&gt; operator
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mutate()&lt;/code&gt; means we are creating or updating a variable inside the tibble
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;across()&lt;/code&gt; allows us perform a function &lt;em&gt;across&lt;/em&gt; many variables within the tibble
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;where()&lt;/code&gt; allows us to specify &lt;em&gt;where&lt;/em&gt; we want &lt;code&gt;across()&lt;/code&gt; to perform the function
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;is.character()&lt;/code&gt;, in the above line, we don’t use the brackets for &lt;code&gt;is.character()&lt;/code&gt; because we’re not applying it, we’re referencing it. We’re telling the &lt;code&gt;where()&lt;/code&gt; function to use this when checking where we want the function to be applied. The &lt;code&gt;is.character()&lt;/code&gt; function returned &lt;code&gt;TRUE&lt;/code&gt; when the variable is a character and &lt;code&gt;FALSE&lt;/code&gt; when it isn’t (e.g. a numeric)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;where()&lt;/code&gt; therefore applies this function to every variable in &lt;code&gt;df&lt;/code&gt; and returns a vector of &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; to &lt;code&gt;across()&lt;/code&gt; to indicate which variables in the tibble we want &lt;code&gt;across()&lt;/code&gt; to act on&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as_factor()&lt;/code&gt; converts things (e.g. characters) into factors.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;across()&lt;/code&gt; has now been passed a logical vector telling it which columns to apply a function and a function that it needs to apply. So it does just that and outputs another tibble&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mutate()&lt;/code&gt; has then been passed a tibble for it’s first argument (&lt;code&gt;df&lt;/code&gt; via the &lt;code&gt;%&amp;lt;&amp;gt;%&lt;/code&gt; pipe) and another tibble as the output of &lt;code&gt;across()&lt;/code&gt;. It stitches these together, if there are any names in common, it overwrites those in &lt;code&gt;df&lt;/code&gt; with those from &lt;code&gt;across()&lt;/code&gt;. All the variables in &lt;code&gt;across()&lt;/code&gt; will also appear in &lt;code&gt;df&lt;/code&gt; because that’s where they came from, so the old values are overwritten with the new ones&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&amp;lt;&amp;gt;%&lt;/code&gt; then receives this new tibble from &lt;code&gt;mutate()&lt;/code&gt; and stores it back into the &lt;code&gt;df&lt;/code&gt; tibble that we originally passed to it. This is essentially saying that &lt;code&gt;df %&amp;lt;&amp;gt;% f()&lt;/code&gt; is the same as &lt;code&gt;df &amp;lt;- df %&amp;gt;% f()&lt;/code&gt;, that’s why this is called the &lt;em&gt;assignment pipe&lt;/em&gt; or &lt;em&gt;updating pipe&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Toward a Framework for the Design, Implementation, and Reporting of Methodology Scoping Reviews</title>
      <link>https://michaelbarrowman.co.uk/publication/martin-2020a/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/publication/martin-2020a/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Getting a variable name in a pipeline</title>
      <link>https://michaelbarrowman.co.uk/post/getting-a-variable-name-in-a-pipeline/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/post/getting-a-variable-name-in-a-pipeline/</guid>
      <description>
&lt;script src=&#34;https://michaelbarrowman.co.uk/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;There is no greater staple of the &lt;code&gt;{tidyverse}&lt;/code&gt; than the pipe, &lt;code&gt;%&amp;gt;%&lt;/code&gt;, however not a lot of people understand what’s going on “under-the-bonnet” of the pipe. To be fair, not many people have to worry about it. Until you start trying to do a bit of meta-programming. Then things can get difficult.&lt;/p&gt;
&lt;p&gt;Recently, a &lt;a href=&#34;https://community.rstudio.com/t/getting-argument-name-when-passed-via-i-keep-getting/74086&#34;&gt;question&lt;/a&gt; posed by user &lt;a href=&#34;https://community.rstudio.com/u/preposterior&#34;&gt;preposterior&lt;/a&gt; on RStudio Community embodied an issue that can happen when trying to extract the name of a variable.&lt;/p&gt;
&lt;p&gt;When using the &lt;code&gt;{rlang}&lt;/code&gt; package, we can get the name of a variable passed into a function using the following:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simple_get_name &amp;lt;- function(x){
  x_sym &amp;lt;- ensym(x)
  as_name(x_sym)
}

my_variable &amp;lt;- 1

simple_get_name(my_variable)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;my_variable&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, when we try to use this with a pipe, it goes wrong:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_variable %&amp;gt;% simple_get_name()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is this!? Where did that dot come from? Well, that’s why you’re here. The &lt;code&gt;.&lt;/code&gt; can actually be used as a variable name in R, it’s perfectly syntactic, although ill-advised. Many functions (particularly &lt;code&gt;{tidyverse}&lt;/code&gt; ones) use the &lt;code&gt;.&lt;/code&gt; as a filler for other purposes, the pipe is a big example, but it is also prominent in the &lt;code&gt;map()&lt;/code&gt; family of functions in &lt;code&gt;{purrr}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The reason we get this output is because the pipe actually turns your pipeline of functions into a chain of new functions defined something like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;function(.)
simple_get_name(.)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, it’s a chain of wrapper functions around your pipeline’d functions. The functions are direct copies of what you use in your pipeline. For example, if you have a few arguments, the &lt;code&gt;.&lt;/code&gt; will be inserted as the first argument. This makes sense as this is what the pipe does (passes your input into the first agrument, unless told otherwise).&lt;/p&gt;
&lt;p&gt;Once the pipe has this chain of functions, it uses the &lt;code&gt;freduce()&lt;/code&gt; function to apply the functions in order to the output of the previous one. You already knew what a pipeline did, know you’ve got a little insight into how.&lt;/p&gt;
&lt;p&gt;So how do we pull out that &lt;code&gt;my_variable&lt;/code&gt; name from within a piped function? Well the problem is that, within the context of that function, that variable is lost. It’s value has been put into the variable &lt;code&gt;.&lt;/code&gt;, but that original name is long gone.&lt;/p&gt;
&lt;p&gt;We can, however, look back over the call-stack where the current function is being evaluated (which is what error-finding functions like &lt;code&gt;traceback()&lt;/code&gt; do). Within the pipe, it actually creates a relatively deeply nested set of calls (about 9 calls deep). However, the &lt;code&gt;sys.calls()&lt;/code&gt; function can return this stack. Compare for example the following two outputs:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stack_fun &amp;lt;- function(x){
  sys.calls()
}
stack_fun(my_variable)
my_variable %&amp;gt;% stack_fun&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## stack_fun(my_variable)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## my_variable %&amp;gt;% stack_fun
## 
## [[2]]
## withVisible(eval(quote(`_fseq`(`_lhs`)), env, env))
## 
## [[3]]
## eval(quote(`_fseq`(`_lhs`)), env, env)
## 
## [[4]]
## eval(quote(`_fseq`(`_lhs`)), env, env)
## 
## [[5]]
## `_fseq`(`_lhs`)
## 
## [[6]]
## freduce(value, `_function_list`)
## 
## [[7]]
## withVisible(function_list[[k]](value))
## 
## [[8]]
## function_list[[k]](value)
## 
## [[9]]
## stack_fun(.)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first element of this stack will be the initial call, in this case &lt;code&gt;my_variable %&amp;gt;% stack_fun()&lt;/code&gt;. This will be a &lt;code&gt;call&lt;/code&gt; object and so we can pull out the left-hand side by extracting the second element (the &lt;code&gt;%&amp;gt;%&lt;/code&gt; is the first element, and &lt;code&gt;stack_fun&lt;/code&gt; is the third). Therefore, the previous function can be written as:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stacked_get_name &amp;lt;- function(x){
  first_call &amp;lt;- sys.calls()[[1]] #get the first entry on the call stack
  lhs &amp;lt;- first_call[[2]] #get the second element of this entry
  z &amp;lt;- rlang::as_name(lhs)
  print(z)
}

my_variable %&amp;gt;% stacked_get_name()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;my_variable&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It worked! Brilliant!&lt;/p&gt;
&lt;p&gt;But, that’s not the end of our tale!&lt;/p&gt;
&lt;p&gt;This is just looking for the initial call, and isn’t strictly going to seek out where there is a pipe. For example, it wouldn’t work with the following function, since &lt;code&gt;wrap_stacked_get_name()&lt;/code&gt; would be at the top of the stack:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;wrap_stacked_get_name &amp;lt;- function(wrapped_var){
  this_variable &amp;lt;- wrapped_var+1
  this_variable %&amp;gt;% stacked_get_name
}

wrap_stacked_get_name(my_variable)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;my_variable&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This should return &lt;code&gt;this_variable&lt;/code&gt;, but since it’s looking at the initial call, it looks too far back up the call-stack and misses this variable.&lt;/p&gt;
&lt;p&gt;However, by inspecting the entire stack for a pipe, we can pull out the most recent (i.e. the lowest) entry that is a pipe, and grab the left-hand side of that call.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_lhs &amp;lt;- function(){
  calls &amp;lt;- sys.calls()
  
  #pull out the function or operator (e.g. the `%&amp;gt;%`)
  call_firsts &amp;lt;- lapply(calls,`[[`,1) 
  
  #check which ones are equal to the pipe
  pipe_calls &amp;lt;- vapply(call_firsts,identical,logical(1),quote(`%&amp;gt;%`))
  
  #if we have no pipes, then get_lhs() was called incorrectly
  if(all(!pipe_calls)){
    NULL
  } else {
    #Get the most recent pipe, lowest on the 
    pipe_calls &amp;lt;- which(pipe_calls)
    pipe_calls &amp;lt;- pipe_calls[length(pipe_calls)]
    
    #Get the second element of the pipe call
    this_call &amp;lt;- calls[[c(pipe_calls,2)]]
    
    #We need to dig down into the call to find the original
    while(is.call(this_call) &amp;amp;&amp;amp; identical(this_call[[1]],quote(`%&amp;gt;%`))){
      this_call &amp;lt;- this_call[[2]]
    }
    this_call
    
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we have the call, getting the lhs of it requires digging down. If we have pipeline, then it’s actually a nested sequence of operators. For example, &lt;code&gt;2+3+4&lt;/code&gt; makes sense to us, but R can’t add like this, it breaks this down by calculating from left to right, basically it does this &lt;code&gt;(2 + 3) + 4&lt;/code&gt;, which is the same as &lt;code&gt;add(add(2,3),4)&lt;/code&gt;. R does this with the pipe too.&lt;/p&gt;
&lt;p&gt;If we’re piping a few things together, we write this: &lt;code&gt;my_variable %&amp;gt;% fun1 %&amp;gt;% fun2 %&amp;gt;% fun3&lt;/code&gt;, R reads it as this: &lt;code&gt;((my_variable %&amp;gt;% fun1) %&amp;gt;% fun2) %&amp;gt;% fun3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So we repeatedly check that the current function/operator/call name is a pipe, if it is, grab the second entry (which is what is being piped into the current pipe). If it isn’t, we’ve dug down far enough.&lt;/p&gt;
&lt;p&gt;So, now that we have that little function, we can re-write our function to check for this first:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_name &amp;lt;- function(x){
  lhs &amp;lt;- get_lhs()
  if(is.null(lhs)){
    lhs &amp;lt;- rlang::ensym(x)
  }
  as_name(lhs)
}
get_name(my_variable)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;my_variable&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_variable %&amp;gt;% get_name&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;my_variable&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Eureka! Now, let’s check the wrapper function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;wrap_get_name &amp;lt;- function(wrapped_var){
  this_variable &amp;lt;- wrapped_var+1
  this_variable %&amp;gt;% get_name
}

wrap_get_name(my_variable)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;this_variable&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_variable %&amp;gt;% wrap_get_name&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;this_variable&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function acts a little strange around &lt;code&gt;fseq&lt;/code&gt; functions. But, the results make sense when you think about it.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fseq_get_name &amp;lt;- . %&amp;gt;% get_name&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method of creating a function, where the initial starting value of the pipeline is actually that previously discussed &lt;code&gt;.&lt;/code&gt;, this is essentially the same as the previous, &lt;code&gt;wrap_get_name()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fseq_get_name_dummy &amp;lt;- function(.){
  . %&amp;gt;% get_name
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As usual, we can use this function in one of two ways, either as a regular function with brackets or as a piped function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fseq_get_name(my_variable)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the alternate definition above, this makes sense as a result. The pipeline starts with a &lt;code&gt;.&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_variable %&amp;gt;% fseq_get_name&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;my_variable&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What? This time, it’s returned the value being piped in. But, if we imagine a &lt;code&gt;fseq&lt;/code&gt;-style as sticking the pipelines together, then the actual start of this pipeline &lt;em&gt;is&lt;/em&gt; the &lt;code&gt;my_variable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And there we go. You’ve now got a bit more of an understanding of the &lt;code&gt;sys.calls()&lt;/code&gt; function and can extract the name of a variable being passed into a pipeline. This is a very basic way of doing it, it doesn’t do nearly enough checks as a function in-production would have to do, but it’s a good start. You could also extract any part of that original pipeline call.&lt;/p&gt;
&lt;p style=&#34;font-size: calc(100% - 6px);&#34;&gt;
Sidenote for the pro’s out there. This page is written in &lt;code&gt;{rmarkdown}&lt;/code&gt; and rendered using &lt;code&gt;{blogdown}&lt;/code&gt;. This meant that when I used the &lt;code&gt;sys.calls()&lt;/code&gt; function, I actually got a much deeper nesting of calls when rendering in these than in my RStudio application. This is because when rendering, each code chunk is evaluated &lt;em&gt;within another call&lt;/em&gt;. For the local render with &lt;code&gt;{rmarkdown}&lt;/code&gt;, I had to remove the first 18 calls before the “first” call was the one actually used above. For the &lt;code&gt;{blogdown}&lt;/code&gt; render, it is 24. This page has a bunch of hidden code chunks (using &lt;code&gt;eval=F&lt;/code&gt; and &lt;code&gt;echo=F&lt;/code&gt;) to make the code and the output look seamless.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploy to GitHub Pages</title>
      <link>https://michaelbarrowman.co.uk/post/deploy-to-github-pages/</link>
      <pubDate>Wed, 22 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/post/deploy-to-github-pages/</guid>
      <description>&lt;p&gt;Within &lt;code&gt;git&lt;/code&gt;, the default branch is usually named &lt;code&gt;master&lt;/code&gt;, however in recent times, the negative connotations of that word are coming to the forefront of a lot of people&amp;rsquo;s minds, and so they are wishing to diverge away from that kind of terminology. The simplest change that we can make is to default to the &lt;code&gt;HEAD&lt;/code&gt; branch of a repo, which will point towards whatever the actual default branch is for a the repo, whether that is &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;main&lt;/code&gt; or &lt;code&gt;Captain&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Unfortunately, this change can be slow, and although resources like GitHub have expressed interest in switching away from the default &lt;code&gt;master&lt;/code&gt;, some things are still hardcoded. One of which is the limitations of GitHub Pages deployment. Users can currently choose from one of three options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build website from the &lt;code&gt;master&lt;/code&gt; branch&lt;/li&gt;
&lt;li&gt;Build website from the &lt;code&gt;docs&lt;/code&gt; folder in the &lt;code&gt;master&lt;/code&gt; branch&lt;/li&gt;
&lt;li&gt;Build website from the &lt;code&gt;gh-pages&lt;/code&gt; branch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The use of &lt;code&gt;master&lt;/code&gt; here is hardcoded, and many users currently choose to use the &lt;code&gt;docs&lt;/code&gt; folder in the &lt;code&gt;master&lt;/code&gt; branch as the location to store their website. Depending on workflows, the other two options might not be possible, or would require huge restructuring of your workflow if you wish to switch from &lt;code&gt;master&lt;/code&gt;. For User pages (repos that are &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;), they can only be built from the &lt;code&gt;master&lt;/code&gt; branch; hopefully this will change soon (see 
&lt;a href=&#34;#User-repos&#34;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;For example, this blog is written using &lt;code&gt;blogdown&lt;/code&gt;, a package for &lt;code&gt;R&lt;/code&gt;, which helps to create blogs. In doing so, it creates a static site in a subdirectory called &lt;code&gt;public&lt;/code&gt; (by default). You do your work in the parent folder, it generates content in this subfolder. If you wish to use GitHub Pages to publish your site, the 
&lt;a href=&#34;https://bookdown.org/yihui/blogdown/github-pages.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;recommendations&lt;/a&gt; by 
&lt;a href=&#34;https://yihui.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;yihui&lt;/a&gt;, the package autho, are to set up your &lt;code&gt;git&lt;/code&gt; directory inside this subdirectory. This has the limitation of meaning the content of your parent folder is not backed up to GitHub, and is only stored locally.&lt;/p&gt;
&lt;p&gt;However, thanks to GitHub user 
&lt;a href=&#34;https://github.com/s0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;s0&lt;/code&gt;&lt;/a&gt; and their GitHub Action, it&amp;rsquo;s possible to keep your work inside the &lt;code&gt;doc&lt;/code&gt; folder on your &lt;code&gt;default&lt;/code&gt; branch (whatever it&amp;rsquo;s name may be) and have that folder automatically pushed to the &lt;code&gt;gh-pages&lt;/code&gt; branch.&lt;/p&gt;
&lt;p&gt;For those who don&amp;rsquo;t know, GitHub Actions allows automation when certain events (triggers) occur within your repo. You can try to write your own complicated commands, or use those created by other users within a relatively simple skeleton. We&amp;rsquo;re going to use one of these simple skeletons to utilise &lt;code&gt;s0&lt;/code&gt;&amp;rsquo;s work, thus allowing us to use the &lt;code&gt;main&lt;/code&gt; branch, rather than the &lt;code&gt;master&lt;/code&gt; branch on our repo. In order to use GitHub Actions, we need to add a 
&lt;a href=&#34;https://en.wikipedia.org/wiki/YAML&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;.yaml&lt;/code&gt;&lt;/a&gt; file (stands for YAML Ain&amp;rsquo;t Markup Language) within our repo.&lt;/p&gt;
&lt;h2 id=&#34;rename-the-branch&#34;&gt;Rename the branch&lt;/h2&gt;
&lt;p&gt;The first step in this process would be to actually change the name of our &lt;code&gt;master&lt;/code&gt; branch to &lt;code&gt;main&lt;/code&gt; (or whatever you choose).&lt;/p&gt;
&lt;h3 id=&#34;directly-on-github&#34;&gt;Directly on GitHub&lt;/h3&gt;
&lt;p&gt;GitHub doesn&amp;rsquo;t directly support renaming of branches (as far as I know). So, what we need to do is to create a new branch for our repository by clicking on the branches button at the top left of our repo Code page (probably says &lt;code&gt;master&lt;/code&gt; right now).&lt;/p&gt;
&lt;p&gt;And then type in the name of the new branch (e.g. &lt;code&gt;main&lt;/code&gt;). If this branch doesn&amp;rsquo;t exist, you&amp;rsquo;ll be given the option to &lt;code&gt;Create branch: main from &#39;master&#39;&lt;/code&gt;. Click on Settings then Branches and you can change your default branch to the new &lt;code&gt;main&lt;/code&gt; branch.&lt;/p&gt;
&lt;p&gt;You can then delete your &lt;code&gt;master&lt;/code&gt; branch, although it might be worth holding on to it for a little while, in case anybody downstream from you is using it, or as a back-up in case something goes wrong!&lt;/p&gt;
&lt;h3 id=&#34;git-bash&#34;&gt;Git Bash&lt;/h3&gt;
&lt;p&gt;If you have a local copy of your repo, you can run the following in command line to rename it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch -m master main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to rename the current branch, you can simplify this to be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch -m main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note you will have to use &lt;code&gt;-M&lt;/code&gt; instead of &lt;code&gt;-m&lt;/code&gt; if you are renaming a branch and only changing captalisation, e.g. from &lt;code&gt;main&lt;/code&gt; to &lt;code&gt;Main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A common error when running this command is the following (or something to this effect):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: refname refs/heads/HEAD not found
fatal: Branch rename failed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means you don&amp;rsquo;t have a branch checked out, and so you&amp;rsquo;ll have to create a new branch, but when doing so, you can name it whatever you want&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After you&amp;rsquo;ve done this locally, you&amp;rsquo;ll have to &lt;code&gt;git push&lt;/code&gt; your repo up to GitHub again. However, you&amp;rsquo;ll probably get an error telling you to run the following instead&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push --set-upstream origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will just ensure your new &lt;code&gt;main&lt;/code&gt; branch is upstream of the previous &lt;code&gt;master&lt;/code&gt; branch.&lt;/p&gt;
&lt;p&gt;Then you&amp;rsquo;ll have to change GitHub&amp;rsquo;s default branch to your new one in the Settings as above.&lt;/p&gt;
&lt;h2 id=&#34;github-workflows&#34;&gt;GitHub Workflows&lt;/h2&gt;
&lt;p&gt;GitHub Action files are stored in a special directory in your repo, the &lt;code&gt;.github/workflow&lt;/code&gt; directory. All we have to do is create a file in this directory, name it something useful and give it the &lt;code&gt;.yaml&lt;/code&gt; extension. Sounds simple, and for most people it is. The only limitation is that sometimes, we can&amp;rsquo;t create folders with the &lt;code&gt;.&lt;/code&gt; at the start (particularly on Windows). Or at least, we can&amp;rsquo;t create them in the usual Right Click &amp;gt; New &amp;gt; Folder method in Windows Explorer. The simple way is to use Command Line to do it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir .github
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;mkdir&lt;/code&gt; command makes directories. It&amp;rsquo;s as simple as that.&lt;/p&gt;
&lt;p&gt;Alternatively, you can create this directly on GitHub in the usual manner. Just remember that you will have to &lt;code&gt;git pull&lt;/code&gt; any changes you make this way.&lt;/p&gt;
&lt;h2 id=&#34;the-yaml&#34;&gt;The YAML&lt;/h2&gt;
&lt;p&gt;The YAML file that we create will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: &#39;Deploy to gh-pages&#39;
on:
  push:	
    branches:
      - main
    paths:	
      - &#39;docs/**&#39;
      
jobs:
  deploy:
    name: Push docs to gh-pages
    runs-on: ubuntu-latest    
    steps:
    - uses: actions/checkout@main

    - name: Deploy
      uses: s0/git-publish-subdir-action@develop
      env:
        REPO: self
        BRANCH: gh-pages
        FOLDER: docs
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Feel free to copy the above directly. If you&amp;rsquo;re using RStudio to manage your repo, you can create a New Text File, save it with the extension &lt;code&gt;.yaml&lt;/code&gt; and RStudio will conveniently colour code the file. Otherwise, you can do it in notepad (just make sure the extension sticks).&lt;/p&gt;
&lt;p&gt;What does this file do? I don&amp;rsquo;t think it&amp;rsquo;s too important to go into great details here, there is plenty of 
&lt;a href=&#34;https://docs.github.com/en/actions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reading to be done&lt;/a&gt; on GitHub Actions. So, just a quick look at the important bits, in case you want to change something. Apart from the &lt;code&gt;name:&lt;/code&gt; line, it&amp;rsquo;s split into two parts, the &lt;code&gt;on:&lt;/code&gt; and the &lt;code&gt;jobs:&lt;/code&gt; parts. Note that in YAML files, whitespace is important, and gives structure: &lt;code&gt;push:&lt;/code&gt; is a child of &lt;code&gt;on:&lt;/code&gt; and &lt;code&gt;jobs:&lt;/code&gt; is the parent of &lt;code&gt;deploy:&lt;/code&gt;, but &lt;code&gt;on:&lt;/code&gt; and &lt;code&gt;jobs:&lt;/code&gt; are siblings.&lt;/p&gt;
&lt;h3 id=&#34;the-triggers&#34;&gt;The Triggers&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;on:&lt;/code&gt; part contains information on what events will trigger the event. Here, we&amp;rsquo;re telling GitHub that we want this Action to run when we push our repo to the &lt;code&gt;main&lt;/code&gt; branch, only if something has changed in the &lt;code&gt;docs&lt;/code&gt; folder (or path). This means that any pushes that happen to other branches will be ignored, and any pushes that don&amp;rsquo;t change our &lt;code&gt;docs&lt;/code&gt; folder will also be ignored. The syntax for &lt;code&gt;paths:&lt;/code&gt; actually allows you to check for changes to anything that matches this string, so by using &lt;code&gt;&#39;docs/**&#39;&lt;/code&gt;, we match anything that starts with &lt;code&gt;&#39;docs/&#39;&lt;/code&gt;, i.e. anything within the &lt;code&gt;docs&lt;/code&gt; folder. This is useful because we&amp;rsquo;re building our &lt;code&gt;gh-pages&lt;/code&gt; branch based solely on what&amp;rsquo;s in &lt;code&gt;docs&lt;/code&gt;. If something changes elsewhere in the repo, it doesn&amp;rsquo;t matter (even if you are accessing data in your repo, but outside of your site because those changes will still be pushed to your repo, just don&amp;rsquo;t need to trigger a site rebuild). It also doesn&amp;rsquo;t matter what happens on other branches (such as a &lt;code&gt;development&lt;/code&gt; branch) because we&amp;rsquo;re not wanting to build our GitHub pages from them.&lt;/p&gt;
&lt;h3 id=&#34;the-actions&#34;&gt;The Actions&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;jobs:&lt;/code&gt; part contains the actual actions that occurs. You can have many Actions and jobs within he same file, but here we only have one job, which consists of two tasks. &lt;code&gt;deploy:&lt;/code&gt; is just the formal name for the job that we&amp;rsquo;re running. If we want more jobs to run, we can give them different names and place them at the same hierarchical starting point as &lt;code&gt;deploy:&lt;/code&gt; (i.e. with two spaces in front). Different jobs will run in parallel, each individual job will run in order.&lt;/p&gt;
&lt;p&gt;We then give a bit of information about the job, first it&amp;rsquo;s name &lt;code&gt;Push docs to gh-pages&lt;/code&gt; (more like a title), followed by what operating system we want GitHub Actions to use to implement it. Finally, we have the &lt;code&gt;steps:&lt;/code&gt;, which is where we put the list of tasks that need to be run (in order).&lt;/p&gt;
&lt;p&gt;This Action only has two steps and they are both &lt;code&gt;uses:&lt;/code&gt; steps, which basically means we&amp;rsquo;re going to be using Actions that are properly defined elsewhere. We could write an action directly here in quotes and supply the name of what application we want it to be run in (at a Command Line level), but we don&amp;rsquo;t have to since these Actions are defined for us. Each task starts with a &lt;code&gt;-&lt;/code&gt; followed by the information for that task.&lt;/p&gt;
&lt;h4 id=&#34;checkout&#34;&gt;Checkout&lt;/h4&gt;
&lt;p&gt;The first task is simple &lt;code&gt;- uses: actions/checkout@master&lt;/code&gt;. You may recognise the format of this as it comes up a lot within GitHub, it is &lt;code&gt;&amp;lt;user&amp;gt;/&amp;lt;repo&amp;gt;@&amp;lt;branch&amp;gt;&lt;/code&gt;. This is because all Actions created by other users, are actually repos. So what we&amp;rsquo;re doing here is saying we want to &lt;code&gt;use&lt;/code&gt; the Action defined within the &lt;code&gt;main&lt;/code&gt; branch of the &lt;code&gt;checkout&lt;/code&gt; repo made by the user &lt;code&gt;actions&lt;/code&gt; and we can actually view that repo 
&lt;a href=&#34;https://github.com/actions/checkout&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;, or since it is an Action, we can view it on the Actions Marketplace 
&lt;a href=&#34;https://github.com/marketplace/actions/checkout&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This Action essentially runs a &lt;code&gt;git checkout&lt;/code&gt; command on your repo so that it&amp;rsquo;s files can be accessed by your workflow. Actions that change your repo in some way will typically start with this. They will usually also end with something that &lt;code&gt;commits&lt;/code&gt; and &lt;code&gt;pushes&lt;/code&gt; the results back onto your repo. We don&amp;rsquo;t need to do this part because it is covered by the second task&lt;/p&gt;
&lt;h4 id=&#34;deploy&#34;&gt;Deploy&lt;/h4&gt;
&lt;p&gt;Task number two is where the magic happens. There&amp;rsquo;s a lot more here than in the first task&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: Deploy
  uses: s0/git-publish-subdir-action@develop
  env:
    REPO: self
    BRANCH: gh-pages
    FOLDER: docs
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have three children within this task, &lt;code&gt;name:&lt;/code&gt;, &lt;code&gt;uses:&lt;/code&gt; and &lt;code&gt;env:&lt;/code&gt; and &lt;code&gt;env:&lt;/code&gt; even has some children of it&amp;rsquo;s own. Firstly, we&amp;rsquo;re giving this task a name, &lt;code&gt;Deploy&lt;/code&gt;; this isn&amp;rsquo;t necessary, but it looks a little neater and makes it clearer what this task is doing (useful if you&amp;rsquo;re running a lot of tasks in a single job).&lt;/p&gt;
&lt;p&gt;The next child is the same as previously, &lt;code&gt;uses: s0/git-publish-subdir-action@develop&lt;/code&gt;. We&amp;rsquo;re going to run the action on the &lt;code&gt;develop&lt;/code&gt; branch of the &lt;code&gt;git-publish-subdir-action&lt;/code&gt; repo by the user &lt;code&gt;s0&lt;/code&gt;. Once again, you can view this repo 
&lt;a href=&#34;https://github.com/s0/git-publish-subdir-action&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt; or as an Action on the Marketplace 
&lt;a href=&#34;https://github.com/marketplace/actions/push-git-subdirectory-as-branch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;. This is main part of what we&amp;rsquo;re doing. This Action does the actual copying of the subdirectory and pushes it to a new branch.&lt;/p&gt;
&lt;p&gt;The last child is &lt;code&gt;env:&lt;/code&gt; and this is where you might have to change things depending on your use-case. This has four children, which are actually variables. Just like in most programming, we work within an environment that contains variables, well here we&amp;rsquo;re going to define some for the &lt;code&gt;git-publish-subdir-action&lt;/code&gt; to use.&lt;/p&gt;
&lt;p&gt;You don&amp;rsquo;t need to worry about &lt;code&gt;REPO&lt;/code&gt; and &lt;code&gt;GITHUB_TOKEN&lt;/code&gt;, these just mean that the action is going to run on the current repo (&lt;code&gt;REPO: self&lt;/code&gt;) and provides authentication that it&amp;rsquo;s really us doing the changes (by generating a &lt;code&gt;GITHUB_TOKEN&lt;/code&gt; to use as an auth token). The other two variables are important, it&amp;rsquo;s telling the Action what directory we want to copy, which by default (if you&amp;rsquo;re been running your GitHub Pages using the &lt;code&gt;master/docs&lt;/code&gt; form) is currently set to be &lt;code&gt;docs&lt;/code&gt;, but this can be any other folder (or sub-folder) in your repo, e.g &lt;code&gt;public/home&lt;/code&gt;, &lt;code&gt;my-gh-pages-site&lt;/code&gt; or &lt;code&gt;&amp;quot;My Homepage&amp;quot;&lt;/code&gt; (don&amp;rsquo;t forget the quotes). Then finally, the name of the branch we want to put it on. If you&amp;rsquo;re looking here with the intention of using a GitHub Page, then this will have to be &lt;code&gt;gh-pages&lt;/code&gt; (unless using a 
&lt;a href=&#34;#User-repos&#34;&gt;User account&lt;/a&gt;), but can be any name you want your new branch to be.&lt;/p&gt;
&lt;h2 id=&#34;check-it-works&#34;&gt;Check it works&lt;/h2&gt;
&lt;p&gt;Finally, once we&amp;rsquo;ve done all this, we can &lt;code&gt;git push&lt;/code&gt; to the &lt;code&gt;main&lt;/code&gt; branch of our repo on GitHub and it should build our website (provided we have the GitHub pages set to use &lt;code&gt;gh-pages&lt;/code&gt;). To check whether this has worked, simply load up your GitHub Page. You can also have a look at the run through of the Action in the Actions tab in your repo home. This gives you the output of the Command Line of every step of your Action (although remember there are only two).&lt;/p&gt;
&lt;h2 id=&#34;user-repos&#34;&gt;User repos&lt;/h2&gt;
&lt;p&gt;User repos are named like &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; and can only be built from the &lt;code&gt;master&lt;/code&gt; branch. This is because User repos are expected to be self-contained and their GitHub Pages site can only be built from the &lt;code&gt;master&lt;/code&gt; branch. This means that you are expected to have an &lt;code&gt;index.html&lt;/code&gt; file in your home directory. However, this can limit the ways in which your site can be built. To fix this, we can use the workflow as above, but instead of pushing the subdirectory to the &lt;code&gt;gh-pages&lt;/code&gt; branch, we push it to the &lt;code&gt;master&lt;/code&gt; branch, whilst still using our &lt;code&gt;main&lt;/code&gt; branch as our default. The only change we need to do, is to replace the &lt;code&gt;BRANCH: gh-pages&lt;/code&gt; line in the YAML file with &lt;code&gt;BRANCH: master&lt;/code&gt; (make sure you keep the whitespace before it).&lt;/p&gt;
&lt;p&gt;If you are using a Custom Domain, there is one last thing that you&amp;rsquo;ll need to consider. When you add a Custom Domain, GitHub stores this as the &lt;code&gt;CNAME&lt;/code&gt; file in your home directory. The Action above destroys the &lt;code&gt;master&lt;/code&gt; branch before rebuilding it from scratch. This includes deleting that &lt;code&gt;CNAME&lt;/code&gt; file and, since it isn&amp;rsquo;t in the subdirectory of your &lt;code&gt;main&lt;/code&gt; branch, it doesn&amp;rsquo;t get put back in. The solution? Just put it in there yourself. This simply means adding a file to your &lt;code&gt;docs&lt;/code&gt; directory called &lt;code&gt;CNAME&lt;/code&gt; (no file extension) and have it&amp;rsquo;s only contents be your url. Since new files without extensions can, again, be tricky. At Command Line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo -n [YOUR_URL_HERE] &amp;gt; docs/CNAME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(The use of &lt;code&gt;-n&lt;/code&gt; here means that a newline isn&amp;rsquo;t added to the end of the line)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How Unmeasured Confounding in a Competing Risks Setting Can Affect Treatment Effect Estimates in Observational Studies</title>
      <link>https://michaelbarrowman.co.uk/publication/barrowman-2019a/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/publication/barrowman-2019a/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Study Investigating the Generalisability of a COPD Trial Based in Primary Care (Salford Lung Study) and the Presence of a Hawthorne Effect</title>
      <link>https://michaelbarrowman.co.uk/publication/pate-2018a/</link>
      <pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/publication/pate-2018a/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Experience</title>
      <link>https://michaelbarrowman.co.uk/experience/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://michaelbarrowman.co.uk/experience/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
